<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="index.css" />
  </head>
  <body>
    <h2>hello world</h2>
    <div class="div_section">
        <div class="div_title">
          new title
        </div>
        <div class="div_desc">
         new desc
        </div>
    </div>
    <div class="div_section">
      <div class="div_title">
       js 数组去重
      </div>
      <div class="div_desc">
        https://juejin.im/post/5aed6110518825671b026bed
      </div>
  </div>
    <div class="div_section">
      <div class="div_title">
         原型链
      </div>
      <div class="div_desc">
        <p>7中基本类型：number,string ,bool,undefined,null,symbol,object</p>
        <p>前6中为基本类型，存的是值，object为引用类型，存的是内存地址</p>
        <p>Object的几种类型：1.普通对象   2. 数组   3.函数</p>
        <p>原型链最初的作用：省内存</p>
      </div>
  </div>
    <div class="div_section">
      <div class="div_title">
        JS中判断对象是对象还是数组的方法
      </div>
      <div class="div_desc">
        <ul>
          <li>
             <p>1.typeof操作符 </p>
            这种方法对于一些常用的类型来说那算是毫无压力，比如Function、String、Number、Undefined等，但是要是检测Array的对象就不起作用了。 利用typeof除了array和null判断为object外，其他的都可以正常判断
          </li>
        </ul>
       
      </div>
  </div>
    <div class="div_section">
        <div class="div_title">
          Flex 布局是什么？(http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)
        </div>
        <div class="div_desc">
          <p>
          布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。
          </p>
          <p>
          Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。
          任何一个容器都可以指定为 Flex 布局。
          行内元素也可以使用 Flex 布局。
          设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
          采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。
         </p>
          <p>
              容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。
          </p>
          <p>
              <p>以下6个属性设置在容器上:</p>
              <ul>
                <li>
                    flex-direction:属性决定主轴的方向
                    <p>
                          .box {
                            flex-direction: row | row-reverse | column | column-reverse;
                          }
                   </p>
                </li>
                <li>
                  flex-wrap:默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。
                  <p>
                      .box{
                        flex-wrap: nowrap | wrap | wrap-reverse;
                      }
                  </p>
                </li>
                <li>
                    flex-flow:是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
                    <p>
                        .box {
                          flex-flow: <flex-direction> || <flex-wrap>;
                        }
                    </p>
                </li>
                <li>
                    justify-content:定义了项目在主轴上的对齐方式。
                    <p>
                        .box {
                          justify-content: flex-start | flex-end | center | space-between | space-around;
                        }
                    </p>
                </li>
                <li>
                    align-items:定义项目在交叉轴上如何对齐。
                    <p>
                        .box {
                          align-items: flex-start | flex-end | center | baseline | stretch;
                        }
                    </p>
                </li>
               <li>
                  align-content:定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
                  <p>
                      .box {
                        align-content: flex-start | flex-end | center | space-between | space-around | stretch;
                      }
                  </p>
               </li>
             
              
              </ul>
              <p>以下6个属性设置在容器子项目上:</p>
              <ul>
                <li>
                    <p>order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
                    <p>
                        .item {
                          order: <integer>;
                        }
                    </p>
                </li>
                <li>
                  <p>  flex-grow:属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
                  <p>
                      .item {
                        flex-grow: <number>; /* default 0 */
                      }
                      如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
                  </p>
                </li>
                <li>
                  <p>flex-shrink:定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
                  <p>
                      .item {
                        flex-shrink: <number>; /* default 1 */
                      }
                      如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
                  </p>
                </li>
                 <li>
                    <p> flex-basis:flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
                    <p>
                        .item {
                          flex-basis: <length> | auto; /* default auto */
                        }
                        它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
                    </p>
                  </li>
                  <li>
                    <p>   flex:性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
                    <p>
                      .item {
                        flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
                      }
                      该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。

建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。
                  </p>
                  </li>
                  <li>
                    <p>   align-self:align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
                   <p>.item {
                      align-self: auto | flex-start | flex-end | center | baseline | stretch;
                    }</p>
                  </li>
             
              </ul>
          </p>
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
          深拷贝 浅拷贝
        </div>
        <div class="div_desc">
            基本数据类型的特点：直接存储在栈(stack)中的数据
            引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里
            <br/>
            浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            redux中间件的理解，以及用过哪些中间件（我自己的博客：https://www.jianshu.com/p/cd94670ab4bf）
        </div>
        <div class="div_desc">
            理解：中间件就是要对redux的store.dispatch方法做一些改造，以实现其他的功能。<br />

        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            Redux的实现流程/ React-redux的实现原理
        </div>
        <div class="div_desc">
            Redux作为一个通用模块，主要还是用来处理应用中state的变更，通过react-redux做连接，可以在React+Redux的项目中将两者结合的更好。
            react-redux是一个轻量级的封装库，它主要通过两个核心方法实现
            <br />
            Provider：从最外部封装了整个应用，并向connect模块传递store。<br />
            Connect： 1、包装原组件，将state和action通过props的方式传入到原组件内部。
                      2、监听store tree变化，使其包装的原组件可以响应state变化
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            React如何性能优化
        </div>
        <div class="div_desc">
          （这个回答不大好。。。要自己再看下。。。。）
            1. 充分利用shouldComponentUpdate函数，不过这需要你的组件尽量最小化，如果当前组件数据过于复杂，其实是很难优化的。
            2. 给你的DOM遍历上加上唯一的key,注意尽量不要用index,因为如果你新DOM中删了某一个节点，它会重新排列index，
            那跟原来同层级一比就都会完全不一样，而重新渲染了，所以最好使用id值什么的作key值。
            
            3. 能用const声明的就用const。
            4. DOM里少用箭头函数，当然其实要传参时也还是得用。再者，函数bind尽量写在constructor，避免每次render重新bind。
            5. 减少对真实DOM的操作。
            6. 如果是用webpack搭建环境的话，当一个包过大加载过慢时，可分打成多个包来优化。
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            react的setState的原理及用法 (来源https://segmentfault.com/a/1190000017140200)
            react 核心成员回答：https://github.com/facebook/react/issues/11527#issuecomment-360199710 
        </div>
        <div class="div_desc">
            当调用setState时，它并不会立即改变，而是会把要修改的状态放入一个任务队列，等到事件循环结束时，再合并指更新
            因此，setState有 异步，合并更新 来更新两个特性。batch update:（https://zhuanlan.zhihu.com/p/28532725）
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            Inheritance and the prototype chain 
        </div>
        <div class="div_desc">
            When it comes to inheritance, JavaScript only has one construct: objects. Each object has a private property which holds a link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype, and acts as the final link in this prototype chain.
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
         什么是原型链（https://zhuanlan.zhihu.com/p/23090041）
         （https://www.zhihu.com/question/56770432/answer/315342130）
        </div>
        <div class="div_desc">
         new desc
        </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        BFC (BLOCK Formatting context，BFC) 块格式化上下文
        （https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context）
      </div>
      <div class="div_desc">
        A block formatting context is a part of a visual CSS rendering of a web
        page. It's the region in which the layout of block boxes occurs and in
        which floats interact with other elements.
        <p>关于BFC的定义：(https://juejin.im/post/5909db2fda2f60005d2093db)</p>
        BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
        我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指BFC中的FC。
        FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。
        常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文），这里就不再展开了。
        通俗一点的方式解释:
        BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC。
      
       <p>触发条件或者说哪些元素会生成BFC：满足下列条件之一就可触发BFC</p> 
    　　【1】根元素，即HTML元素
    　　【2】float的值不为none
    　　【3】overflow的值不为visible
    　　【4】display的值为inline-block、table-cell、table-caption
    　　【5】position的值为absolute或fixed
         .....
      </div>
    </div>

    </div>
    <div class="div_section">
      <div class="div_title">
        强缓存（通过Expires和Cache-Control两种响应头实现）(https://github.com/amandakelake/blog/issues/41)
      </div>
      <div class="div_desc">
        <ul>
          <ul>
            <li>
              Expires
              <div>
                Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。
                Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效
              </div>
            </li>
            <li>
              Cache-Control
              <div>
                Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires
                ,表示的是相对时间
              </div>
            </li>
          </ul>
        </ul>
      </div>
    </div>
    <div class="div_section">
      <div class="div_title">
        手写AJAX 代码中的this JSONP CORS 跨域 闭包/立即执行函数(方方文章)
      </div>
      <div class="div_desc"></div>
    </div>
    <div class="div_section">
      <div class="div_title">
        性能优化(https://www.cnblogs.com/xiaohuochai/p/9178390.html)
      </div>
      <div class="div_desc">
        <ul>
          <li>
            1.减少请求数
            <ul>
              <li>
                文件合并带来的问题： 1.首屏渲染 2.缓存失效 <br />
                一般措施：（公共库合并，不同页面单独渲染）
              </li>
            </ul>
          </li>
          <li>
            2.减小资源大小
          </li>
          <li>
            3.优化网络连接
            <ul>
              <li>
                使用CDN
              </li>
            </ul>
          </li>
          <li>
            优化资源加载
          </li>
          <li>
            减少重绘回流
          </li>
          <li>更好性能的API</li>
          <li>
            webpack优化
            <ul>
              <li>
                打包公共代码
                <div>
                  使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件
                </div>
              </li>
              <li>
                动态导入和按需加载
                <div>
                  webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合
                  ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack
                  特定的 require.ensure
                </div>
              </li>
              <li>
                剔除无用代码
                <div>
                  tree shaking 是一个术语，通常用于描述移除 JavaScript
                  上下文中的未引用代码(dead-code)。它依赖于 ES2015
                  模块系统中的静态结构特性，例如 import 和
                  export。这个术语和概念实际上是兴起于 ES2015 模块打包工具
                  rollup 　　JS的tree
                  shaking主要通过uglifyjs插件来完成，CSS的tree
                  shaking主要通过purify CSS来实现的
                </div>
              </li>
              <li>
                长缓存优化
                <div>
                  1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效
                  　　2、使用Name而不是id 　　每个 module.id
                  会基于默认的解析顺序(resolve
                  order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变
                  　　下面来使用两个插件解决这个问题。第一个插件是
                  NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用
                  HashedModuleIdsPlugin，推荐用于生产环境构建
                </div>
              </li>
              <li>
                公用代码内联
                <div>
                  使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        react 生命周期 three things in lifecycle
      </div>
      <div class="div_desc">
        <br />
        1. initial render <br />
        2. change something ,rerender <br />
        3. destroy the component <br />
        <br />
        生命周期hooks: initial render 包括： <br />
        1. constructor() constructor only runs one time ,it only runs when it
        initially render,good place to set the initial state.
        <br />
        2. componentWillMount() only runs once, can change state base on props.
        also if you want to do something with the global events, like a window
        or document,you can set it here.
        <br />
        3. render() takes the state and props and renders our component,not to
        call the setstate in the render.
        <br />
        4. componentDidMount() only runs once. only runs during the initial
        cycle.you can make ajax call here.
        <br />
        <br />
        change something,包括 <br />
        1. componentWillReceiveProps() could setState here sometime <br />
        2. shouldComponentUpdate() <br />
        3. componentWillUpdate() do not run setState here <br />
        4. componentDidUpdate() <br />

        <br />
        destroy the component包括 <br />
        1. componentWillUnmount()
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        var let const (https://www.youtube.com/watch?v=sjyJBL5fkp8)
      </div>
      <div class="div_desc">
        es5,only one type of variable scope,that is function scope .
        <br />
        let introduces block scope.
        <br />
        const is just like let,expect that you can't change it(actually ,it's
        you can't not reassign it).
        <br />
        encourage const . because of minimize mutable state
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        手写AJAX 代码中的this JSONP CORS 跨域 闭包/立即执行函数(方方文章)
      </div>
      <div class="div_desc"></div>
    </div>

    <div class="div_section">
      <div class="div_title">closures</div>
      <div class="div_desc">
        in javascript ,functions are not just functions.they are also closures.
        what that means is that the function body has access to variables that
        are defined outside function body. why useful?
        (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        React Lazy Loading & Code
        splitting(https://www.youtube.com/watch?v=tV9gvls8IP8&t=1s)
        <br />
        Dynamic imports (https://www.youtube.com/watch?v=km_lcTUgrsE)
      </div>
      <div class="div_desc"></div>
    </div>

    <div class="div_section">
      <div class="div_title">How setState work?</div>
      <div class="div_desc">
        this.setState is asynchronous. the value of state does not immediately
        change after calling this funciton. but it has a second function we can
        pass,it's a callback,it gonna be called whenever the state is updated.
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        <button id="button1">函数节流功能测试</button>
      </div>
      <div class="div_desc">
        <img class="div_img" src="images/Snip20190908_1.png" />
      </div>
    </div>
    <div class="div_section">
      <div class="div_title">
        <button id="button2">函数防抖功能测试</button>
      </div>
      <div class="div_desc">
        <img class="div_img" src="images/Snip20190908_2.png" />
      </div>
    </div>
    <div>
      <ul>
        <li>css性能问题，常用CSS选择器，伪类，伪元素，flex布局，像素单位（px,rem,em?,vw,vh）</li>
        <li>dom操作</li>
        <li>图片懒加载视口判断</li>
        <li>webpack 动态拆分怎么写代码？!!!!</li>
        <li>https 缓存策略，怎么做</li>
        <li>css （js)?浏览器兼容策略</li>
        <li>react hook</li>
        <li> css 传统两栏布局</li>
        <li> js super() 如何判断一个对象？？</li>
        <li> Promise.all 的实现？</li>
        <li> react,redux里为什么要用到immutable.js的原因 https://daveceddia.com/react-redux-immutability-guide/#react-prefers-immutability</li>
        <li>tbj?</li>
        <li>promise : catch (https://stackoverflow.com/questions/33445415/javascript-promises-reject-vs-throw/38181613)</li>
        <li>----------------------------------------------------------------</li>
        <li>symbol --done</li>
        <li>for of for in 如何实现？</li>
        <li>react 算法 fiber？？</li>
        <li>tree shaking</li>
        <li>import 循环引用</li>
        <li>react 事件机制</li>
        <li>redux 怎么去引起state变化</li>
        <li>import 和 require不同</li>
        <li>componentWillReceiveProps -- unsafe new Hooks</li>

        <li>模块解释好文：http://www.json119.com/es6mo-kuai-jia-zai-ji-zhi-xiang-jie/</li>
      </ul>
    </div>

    <script src="index.js"></script>
  </body>
</html>
