<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="index.css" />
  </head>
  <body>
    <h2>hello world</h2>
    <div class="div_section">
        <div class="div_title">
          new title
        </div>
        <div class="div_desc">
         new desc
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
          new title
        </div>
        <div class="div_desc">
         new desc
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
          深拷贝 浅拷贝
        </div>
        <div class="div_desc">
            基本数据类型的特点：直接存储在栈(stack)中的数据
            引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里
            <br/>
            浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            redux中间件的理解，以及用过哪些中间件（我自己的博客：https://www.jianshu.com/p/cd94670ab4bf）
        </div>
        <div class="div_desc">
            理解：中间件就是要对redux的store.dispatch方法做一些改造，以实现其他的功能。<br />

        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            Redux的实现流程/ React-redux的实现原理
        </div>
        <div class="div_desc">
            Redux作为一个通用模块，主要还是用来处理应用中state的变更，通过react-redux做连接，可以在React+Redux的项目中将两者结合的更好。
            react-redux是一个轻量级的封装库，它主要通过两个核心方法实现
            <br />
            Provider：从最外部封装了整个应用，并向connect模块传递store。<br />
            Connect： 1、包装原组件，将state和action通过props的方式传入到原组件内部。
                      2、监听store tree变化，使其包装的原组件可以响应state变化
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            React如何性能优化
        </div>
        <div class="div_desc">
          （这个回答不大好。。。要自己再看下。。。。）
            1. 充分利用shouldComponentUpdate函数，不过这需要你的组件尽量最小化，如果当前组件数据过于复杂，其实是很难优化的。
            2. 给你的DOM遍历上加上唯一的key,注意尽量不要用index,因为如果你新DOM中删了某一个节点，它会重新排列index，
            那跟原来同层级一比就都会完全不一样，而重新渲染了，所以最好使用id值什么的作key值。
            
            3. 能用const声明的就用const。
            4. DOM里少用箭头函数，当然其实要传参时也还是得用。再者，函数bind尽量写在constructor，避免每次render重新bind。
            5. 减少对真实DOM的操作。
            6. 如果是用webpack搭建环境的话，当一个包过大加载过慢时，可分打成多个包来优化。
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            react的setState的原理及用法 (来源https://segmentfault.com/a/1190000017140200)
            react 核心成员回答：https://github.com/facebook/react/issues/11527#issuecomment-360199710 
        </div>
        <div class="div_desc">
            当调用setState时，它并不会立即改变，而是会把要修改的状态放入一个任务队列，等到事件循环结束时，再合并指更新
            因此，setState有 异步，合并更新 来更新两个特性。batch update:（https://zhuanlan.zhihu.com/p/28532725）
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
            Inheritance and the prototype chain 
        </div>
        <div class="div_desc">
            When it comes to inheritance, JavaScript only has one construct: objects. Each object has a private property which holds a link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype, and acts as the final link in this prototype chain.
        </div>
    </div>
    <div class="div_section">
        <div class="div_title">
         什么是原型链（https://zhuanlan.zhihu.com/p/23090041）
         （https://www.zhihu.com/question/56770432/answer/315342130）
        </div>
        <div class="div_desc">
         new desc
        </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        BFC (BLOCK Formatting context，BFC) 块格式化上下文
        （https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context）
      </div>
      <div class="div_desc">
        A block formatting context is a part of a visual CSS rendering of a web
        page. It's the region in which the layout of block boxes occurs and in
        which floats interact with other elements.
        <p>关于BFC的定义：(https://juejin.im/post/5909db2fda2f60005d2093db)</p>
        BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
        我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指BFC中的FC。
        FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。
        常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文），这里就不再展开了。
        通俗一点的方式解释:
        BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC。
      
       <p>触发条件或者说哪些元素会生成BFC：满足下列条件之一就可触发BFC</p> 
    　　【1】根元素，即HTML元素
    　　【2】float的值不为none
    　　【3】overflow的值不为visible
    　　【4】display的值为inline-block、table-cell、table-caption
    　　【5】position的值为absolute或fixed
         .....
      </div>
    </div>

    </div>
    <div class="div_section">
      <div class="div_title">
        强缓存（通过Expires和Cache-Control两种响应头实现）(https://github.com/amandakelake/blog/issues/41)
      </div>
      <div class="div_desc">
        <ul>
          <ul>
            <li>
              Expires
              <div>
                Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。
                Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效
              </div>
            </li>
            <li>
              Cache-Control
              <div>
                Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires
                ,表示的是相对时间
              </div>
            </li>
          </ul>
        </ul>
      </div>
    </div>
    <div class="div_section">
      <div class="div_title">
        手写AJAX 代码中的this JSONP CORS 跨域 闭包/立即执行函数(方方文章)
      </div>
      <div class="div_desc"></div>
    </div>
    <div class="div_section">
      <div class="div_title">
        性能优化(https://www.cnblogs.com/xiaohuochai/p/9178390.html)
      </div>
      <div class="div_desc">
        <ul>
          <li>
            1.减少请求数
            <ul>
              <li>
                文件合并带来的问题： 1.首屏渲染 2.缓存失效 <br />
                一般措施：（公共库合并，不同页面单独渲染）
              </li>
            </ul>
          </li>
          <li>
            2.减小资源大小
          </li>
          <li>
            3.优化网络连接
            <ul>
              <li>
                使用CDN
              </li>
            </ul>
          </li>
          <li>
            优化资源加载
          </li>
          <li>
            减少重绘回流
          </li>
          <li>更好性能的API</li>
          <li>
            webpack优化
            <ul>
              <li>
                打包公共代码
                <div>
                  使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件
                </div>
              </li>
              <li>
                动态导入和按需加载
                <div>
                  webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合
                  ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack
                  特定的 require.ensure
                </div>
              </li>
              <li>
                剔除无用代码
                <div>
                  tree shaking 是一个术语，通常用于描述移除 JavaScript
                  上下文中的未引用代码(dead-code)。它依赖于 ES2015
                  模块系统中的静态结构特性，例如 import 和
                  export。这个术语和概念实际上是兴起于 ES2015 模块打包工具
                  rollup 　　JS的tree
                  shaking主要通过uglifyjs插件来完成，CSS的tree
                  shaking主要通过purify CSS来实现的
                </div>
              </li>
              <li>
                长缓存优化
                <div>
                  1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效
                  　　2、使用Name而不是id 　　每个 module.id
                  会基于默认的解析顺序(resolve
                  order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变
                  　　下面来使用两个插件解决这个问题。第一个插件是
                  NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用
                  HashedModuleIdsPlugin，推荐用于生产环境构建
                </div>
              </li>
              <li>
                公用代码内联
                <div>
                  使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        react 生命周期 three things in lifecycle
      </div>
      <div class="div_desc">
        <br />
        1. initial render <br />
        2. change something ,rerender <br />
        3. destroy the component <br />
        <br />
        生命周期hooks: initial render 包括： <br />
        1. constructor() constructor only runs one time ,it only runs when it
        initially render,good place to set the initial state.
        <br />
        2. componentWillMount() only runs once, can change state base on props.
        also if you want to do something with the global events, like a window
        or document,you can set it here.
        <br />
        3. render() takes the state and props and renders our component,not to
        call the setstate in the render.
        <br />
        4. componentDidMount() only runs once. only runs during the initial
        cycle.you can make ajax call here.
        <br />
        <br />
        change something,包括 <br />
        1. componentWillReceiveProps() could setState here sometime <br />
        2. shouldComponentUpdate() <br />
        3. componentWillUpdate() do not run setState here <br />
        4. componentDidUpdate() <br />

        <br />
        destroy the component包括 <br />
        1. componentWillUnmount()
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        var let const (https://www.youtube.com/watch?v=sjyJBL5fkp8)
      </div>
      <div class="div_desc">
        es5,only one type of variable scope,that is function scope .
        <br />
        let introduces block scope.
        <br />
        const is just like let,expect that you can't change it(actually ,it's
        you can't not reassign it).
        <br />
        encourage const . because of minimize mutable state
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        手写AJAX 代码中的this JSONP CORS 跨域 闭包/立即执行函数(方方文章)
      </div>
      <div class="div_desc"></div>
    </div>

    <div class="div_section">
      <div class="div_title">closures</div>
      <div class="div_desc">
        in javascript ,functions are not just functions.they are also closures.
        what that means is that the function body has access to variables that
        are defined outside function body. why useful?
        (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        React Lazy Loading & Code
        splitting(https://www.youtube.com/watch?v=tV9gvls8IP8&t=1s)
        <br />
        Dynamic imports (https://www.youtube.com/watch?v=km_lcTUgrsE)
      </div>
      <div class="div_desc"></div>
    </div>

    <div class="div_section">
      <div class="div_title">How setState work?</div>
      <div class="div_desc">
        this.setState is asynchronous. the value of state does not immediately
        change after calling this funciton. but it has a second function we can
        pass,it's a callback,it gonna be called whenever the state is updated.
      </div>
    </div>

    <div class="div_section">
      <div class="div_title">
        <button id="button1">函数节流功能测试</button>
      </div>
      <div class="div_desc">
        <img class="div_img" src="images/Snip20190908_1.png" />
      </div>
    </div>
    <div class="div_section">
      <div class="div_title">
        <button id="button2">函数防抖功能测试</button>
      </div>
      <div class="div_desc">
        <img class="div_img" src="images/Snip20190908_2.png" />
      </div>
    </div>
    <div>
      <ul>
        <li>css性能问题，常用CSS选择器，伪类，伪元素，flex布局，像素单位（px,rem,em?,vw,vh）</li>
        <li>dom操作</li>
        <li>图片懒加载视口判断</li>
        <li>react memo??</li>
        <li>webpack 动态拆分怎么写代码？</li>
        <li>https 缓存策略，怎么做</li>
        <li>css （js)?浏览器兼容策略</li>
      </ul>
    </div>

    <script src="index.js"></script>
  </body>
</html>
